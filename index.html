<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Shake Torch</title>
<style>
  :root { --bg:#0b1220; --card:#0f1724; --accent:#ffd166; --muted:#9aa4b2; }
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;background:linear-gradient(180deg,#071022,#0b1220);color:#e6eef8;display:flex;align-items:center;justify-content:center;height:100vh;margin:0}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01)); padding:20px;border-radius:14px; width:min(420px,92vw); box-shadow:0 6px 30px rgba(0,0,0,0.6); text-align:center}
  h1{margin:0 0 8px;font-size:20px}
  p{color:var(--muted);margin:6px 0 16px;font-size:14px}
  .status{display:flex;gap:10px;align-items:center;justify-content:center;margin-bottom:12px}
  .dot{width:14px;height:14px;border-radius:50%;background:#4b5563;box-shadow:0 0 6px rgba(0,0,0,0.4)}
  .dot.on{background:var(--accent); box-shadow:0 0 10px rgba(255,209,102,0.12)}
  button{background:transparent;border:1px solid rgba(255,255,255,0.08);padding:12px 16px;border-radius:10px;color:inherit;font-size:15px;cursor:pointer}
  button.primary{background:var(--accent);color:#07202a;border:none;font-weight:600}
  .big-toggle{width:110px;height:110px;border-radius:999px;border:6px solid rgba(255,255,255,0.04);display:inline-flex;align-items:center;justify-content:center;margin:10px auto 12px;font-size:18px}
  .muted{color:var(--muted);font-size:13px}
  small{display:block;margin-top:8px;color:var(--muted)}
</style>
</head>
<body>
  <div class="card">
    <h1>Shake → Flashlight</h1>
    <p>Shake your phone to switch the rear torch ON while shaking. Torch automatically turns OFF a short time after shaking stops.</p>

    <div class="status" aria-live="polite">
      <div id="torchDot" class="dot" title="torch status"></div>
      <div id="motionDot" class="dot" title="motion status"></div>
      <div style="text-align:left">
        <div id="torchText">Torch: <strong>Unknown</strong></div>
        <div id="motionText" class="muted">Motion: <span id="motionState">Idle</span></div>
      </div>
    </div>

    <div class="big-toggle" id="permissionArea">
      <button id="startBtn" class="primary">Enable</button>
    </div>

    <div style="display:flex;gap:8px;justify-content:center">
      <button id="stopBtn">Stop & Release Camera</button>
      <button id="helpBtn">How to use</button>
    </div>

    <small id="note">Note: Torch API support varies by device/browser. Best on Chrome for Android with a rear camera.</small>
  </div>

<script>
/*
  Shake-Torch web app
  - Uses DeviceMotion to detect shakes
  - Uses getUserMedia + MediaStreamTrack.applyConstraints({advanced:[{torch:true}]}) to toggle torch
  - Keeps torch ON while shakes occur, and automatically turns it OFF after shake stops.
*/

let stream = null;
let videoTrack = null;
let torchAvailable = false;
let torchOn = false;

const OFF_DELAY_MS = 1400; // time of inactivity (no shakes) after which torch turns off
let lastShakeTs = 0;
let checkIntervalId = null;

// UI
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const helpBtn = document.getElementById('helpBtn');
const torchDot = document.getElementById('torchDot');
const motionDot = document.getElementById('motionDot');
const torchText = document.getElementById('torchText');
const motionState = document.getElementById('motionState');

function setTorchUI(on){
  torchOn = !!on;
  torchDot.classList.toggle('on', torchOn);
  torchText.innerHTML = 'Torch: <strong>' + (torchOn ? 'ON' : 'OFF') + '</strong>';
}

function setMotionUI(active){
  motionDot.classList.toggle('on', active);
  motionState.textContent = active ? 'Shaking' : 'Idle';
}

// --- Shake detection logic ---
// Simple algorithm: compute acceleration magnitude (including gravity or without depending on browser).
// When spikes above threshold, consider that a shake.
let lastAccel = {x:0,y:0,z:0};
const SHAKE_THRESHOLD = 13; // m/s^2 threshold for a strong shake (tweak if needed)
const SHAKE_COOLDOWN_MS = 150; // ignore shakes that occur too close together

let lastShakeDetect = 0;

function handleMotion(e){
  // Some browsers supply acceleration and accelerationIncludingGravity.
  const a = e.acceleration || e.accelerationIncludingGravity;
  if (!a) return;
  const ax = a.x || 0;
  const ay = a.y || 0;
  const az = a.z || 0;
  const mag = Math.sqrt(ax*ax + ay*ay + az*az);

  const now = performance.now();
  if (mag > SHAKE_THRESHOLD && (now - lastShakeDetect) > SHAKE_COOLDOWN_MS){
    lastShakeDetect = now;
    onShakeDetected();
  }
}

function onShakeDetected(){
  // mark last shake time, set UI, and ensure torch is on
  lastShakeTs = Date.now();
  setMotionUI(true);
  if (torchAvailable) enableTorch(true);
}

// Periodically check inactivity
function startInactivityChecker(){
  if (checkIntervalId) return;
  checkIntervalId = setInterval(()=>{
    if (!lastShakeTs) return;
    const delta = Date.now() - lastShakeTs;
    if (delta > OFF_DELAY_MS){
      // no shake recently -> turn off torch & reset motion UI
      if (torchAvailable) enableTorch(false);
      setMotionUI(false);
      lastShakeTs = 0;
    }
  }, 250);
}

function stopInactivityChecker(){
  if (checkIntervalId){
    clearInterval(checkIntervalId);
    checkIntervalId = null;
  }
}

// --- Torch control --- 
async function acquireCameraStream(){
  // request rear camera
  try{
    stream = await navigator.mediaDevices.getUserMedia({video:{facingMode: { ideal: "environment" } }});
    videoTrack = stream.getVideoTracks()[0];
    // Check capability for torch
    const caps = videoTrack.getCapabilities ? videoTrack.getCapabilities() : {};
    torchAvailable = !!(caps && caps.torch);
    if (!torchAvailable){
      // Some devices allow torch by advanced constraints even if capabilities doesn't advertise; we will still attempt
      // but mark not available until a successful applyConstraints(true) happens.
      console.warn('Torch capability not advertised by getCapabilities().');
    }
    return true;
  }catch(err){
    console.error('Camera access denied or error:', err);
    alert('Camera permission required for controlling torch. Error: ' + (err.message || err));
    return false;
  }
}

async function enableTorch(on){
  if (!videoTrack){
    console.warn('No camera track to apply torch.');
    return;
  }
  try{
    // Some browsers require the stream to be playing in a visible or hidden video element.
    // Create a hidden <video> element and attach the stream once.
    ensureHiddenVideoPlaying();

    await videoTrack.applyConstraints({advanced:[{torch: !!on}]});
    setTorchUI(on);
    // If capability wasn't advertised but applyConstraints succeeded, set torchAvailable true
    torchAvailable = true;
  }catch(err){
    console.error('applyConstraints error (torch):', err);
    // If constraint fails, mark torch unsupported
    torchAvailable = false;
    setTorchUI(false);
    alert('This browser/device does not support torch control from web pages.');
  }
}

let hiddenVideo = null;
function ensureHiddenVideoPlaying(){
  if (hiddenVideo) return;
  hiddenVideo = document.createElement('video');
  hiddenVideo.style.width = '1px';
  hiddenVideo.style.height = '1px';
  hiddenVideo.style.position = 'fixed';
  hiddenVideo.style.left = '-9999px';
  hiddenVideo.autoplay = true;
  hiddenVideo.playsInline = true;
  hiddenVideo.muted = true;
  document.body.appendChild(hiddenVideo);
  hiddenVideo.srcObject = stream;
  // start playing (some browsers require user interaction before play)
  const playPromise = hiddenVideo.play();
  if (playPromise && playPromise.catch){
    playPromise.catch(()=>{/* ignore play failure */});
  }
}

async function releaseCamera(){
  // turn off torch if on and stop tracks
  try{
    if (videoTrack){
      try { await videoTrack.applyConstraints({advanced:[{torch:false}]}); } catch(e){ /* ignore */ }
    }
  }catch(e){/* ignore */}
  if (stream){
    stream.getTracks().forEach(t=>t.stop());
  }
  stream = null;
  videoTrack = null;
  torchAvailable = false;
  setTorchUI(false);
  setMotionUI(false);
  lastShakeTs = 0;
  if (hiddenVideo){
    hiddenVideo.pause();
    hiddenVideo.srcObject = null;
    hiddenVideo.remove();
    hiddenVideo = null;
  }
}

// --- Permission helpers (iOS 13+ DeviceMotion) ---
async function requestDeviceMotionPermissionIfNeeded(){
  if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function'){
    // iOS 13+ requires explicit permission
    try{
      const resp = await DeviceMotionEvent.requestPermission();
      if (resp !== 'granted'){
        alert('Device Motion permission was not granted. Shake detection will not work.');
        return false;
      }
      return true;
    }catch(err){
      console.warn('DeviceMotion permission request error', err);
      return false;
    }
  }
  // Other browsers do not require
  return true;
}

// --- Start / Stop handlers ---
async function startApp(){
  startBtn.disabled = true;
  startBtn.textContent = 'Enabling...';
  // Request device motion permission if required
  const motionOk = await requestDeviceMotionPermissionIfNeeded();
  // Acquire camera
  const camOk = await acquireCameraStream();
  if (!camOk){
    startBtn.disabled = false;
    startBtn.textContent = 'Enable';
    return;
  }

  // Try to enable torch false initially (to test capability)
  if (videoTrack){
    try{
      // Some devices will throw if unsupported. We ignore errors here.
      await videoTrack.applyConstraints({advanced:[{torch:false}]});
      // if no error, torchAvailable may be true (but getCapabilities is authoritative if present)
      const caps = videoTrack.getCapabilities ? videoTrack.getCapabilities() : {};
      if (caps && caps.torch) torchAvailable = true;
    }catch(err){
      // not fatal, capability may still exist when toggling on later
      console.log('initial torch test failed:', err);
    }
  }

  // Attach listener for motion
  window.addEventListener('devicemotion', handleMotion, {passive:true});
  startInactivityChecker();

  startBtn.style.display = 'none';
  startBtn.disabled = false;
  startBtn.textContent = 'Enable';
  document.getElementById('note').textContent = torchAvailable ? 'Ready. Shake to turn the torch on.' : 'Camera OK but torch not advertised — try shaking to test. If it still doesn\'t work, your browser/device likely does not support torch control.';
  setTorchUI(false);
}

function stopApp(){
  window.removeEventListener('devicemotion', handleMotion);
  stopInactivityChecker();
  releaseCamera();
  startBtn.style.display = '';
  document.getElementById('note').textContent = 'Stopped. Click Enable to start again.';
}

startBtn.addEventListener('click', startApp);
stopBtn.addEventListener('click', stopApp);
helpBtn.addEventListener('click', ()=>alert(
  'How to use:\n\n1. Tap "Enable" and grant camera/motion permissions.\n2. Shake your phone (strong short shakes) while holding the phone — the rear torch should turn on while shaking.\n3. The torch will automatically turn off after you stop shaking.\n\nNotes:\n- Best supported on Chrome for Android with rear camera.\n- iOS Safari generally does not allow torch via web pages.'
));

// Turn off torch when page is hidden (optional safety)
document.addEventListener('visibilitychange', ()=>{
  if (document.hidden){
    if (torchAvailable) enableTorch(false);
  }
});

// Clean up on unload
window.addEventListener('pagehide', ()=>{ stopApp(); });

</script>
</body>
</html>
